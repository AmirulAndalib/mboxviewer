// CustomMsgBox.cpp : implementation file
//

#include "stdafx.h"
#include "afxdialogex.h"
#include "CustomMsgBox.h"
#include "MainFrm.h"
#include "mboxview.h"

// CustomMsgBox dialog

IMPLEMENT_DYNAMIC(CustomMsgBox, CDialogEx)

CustomMsgBox::CustomMsgBox(CWnd* pParent /*=nullptr*/)
	: CDialogEx(IDD_CUSTOM_MSG_BOX, pParent)
{
	m_textStr = L"This dialog enables users to configure the root data folder."
		" MBox Viewer will create a UMBoxViewer folder under the configured root data folder"
		" for all files generated by MBox Viewer such as mails exported in PDF format.\n\n"
		"IMPORTANT: Data Folder path should be as short as possible to avoid truncation of names of files generated by MBox Viewer."
		" Note that the file path is limited to 255 characters.";

	m_textFontHeight = 12;
	m_StatusBarHeight = 12;
}

CustomMsgBox::CustomMsgBox(LPCWSTR lpszText, LPCWSTR lpszCaption, UINT nType, int textFontHeight, CWnd* pParent)
	: CDialogEx(IDD_CUSTOM_MSG_BOX, pParent)
{
	m_textStr.Append(lpszText);
	captionStr.Append(lpszCaption);
	m_textFontHeight = textFontHeight;
	m_nStyle = nType;

	m_StatusBarHeight = 12;

	m_textStr = L"This dialog enables users to configure the root data folder."
		" MBox Viewer will create a UMBoxViewer folder under the configured root data folder"
		" for all files generated by MBox Viewer such as mails exported in PDF format.\n\n"
		"IMPORTANT: Data Folder path should be as short as possible to avoid truncation of names of files generated by MBox Viewer."
		" Note that the file path is limited to 255 characters.";
}

CustomMsgBox::~CustomMsgBox()
{
}

void CustomMsgBox::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
	DDX_Control(pDX, IDCANCEL, m_button1);
	DDX_Control(pDX, IDOK, m_button2);
	DDX_Control(pDX, ID_MSG_BOX_BUTTON3, m_button3);
	DDX_Control(pDX, IDC_MSG_BOX_EDIT_TEXT, m_text);
	DDX_Control(pDX, IDC_MSG_BOX_ICON, m_icon);
	DDX_Control(pDX, IDC_MSG_BOX_GRIPPER, m_gripper);
}

BOOL CustomMsgBox::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	// TODO:  Add extra initialization here

#if 0
// Need o figure out how to create Gripper icon
// Instead decided to write  arrow character into CStatic as the gripper. 
// I think it works OK to indicate resizing feature
//
// Decided to install CStatusBar with Gripper, not ideal solution
//
	m_gripper.ModifyStyle(0, WS_CHILD | WS_VISIBLE | SS_ICON | SS_GRAYFRAME);  // SS_ICON seems to be required for strange reason
	CString arrow = L" \u21D8";
	//arrow = L" \u2198";
	// arrow = L" \u21F2";
	m_gripper.SetWindowText(arrow);
#endif

	m_text.EnableWindow(TRUE);
	m_text.SetFont(&CMainFrame::m_dfltFont);


	// Hide for now
	m_gripper.ShowWindow(SW_HIDE);

	// Create CStatusBar to create Gripper to make user aware of resing capability
	DWORD dwCtrlStatusStyle = WS_CHILD | WS_VISIBLE | CBRS_BOTTOM | CBRS_GRIPPER;
	if (!m_wndStatusBar.CreateEx(this, 0, dwCtrlStatusStyle))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	BOOL retM = m_wndStatusBar.ModifyStyle(0, CBRS_GRIPPER);  // just is case

	m_wndStatusBar.GetStatusBarCtrl().SetSimple();  // no harm ??
	m_wndStatusBar.GetStatusBarCtrl().SetMinHeight(m_StatusBarHeight);

	// Calculate text rectangle size, width and height
	// CString fontName = CMainFrame::m_dfltFontName;

	LOGFONT logFont;
	CWnd* p = 0;
	p = GetDlgItem(ID_MSG_BOX_BUTTON3);
	if (p)
	{
		p->EnableWindow(FALSE);
		p->ShowWindow(SW_HIDE);
	}

	p = GetDlgItem(IDOK);
	if (p)
	{
		p->EnableWindow(TRUE);
	}

	p = GetDlgItem(IDCANCEL);
	if (p)
	{
		p->EnableWindow(TRUE);
	}

	BOOL bRepaint = TRUE;


	// From .rc file
	// --------------

	CRect recDlgRc;
	GetWindowRect(&recDlgRc);

	int wRecDlgRc = recDlgRc.Width();
	int hRecDlgRc = recDlgRc.Height();

	CRect recTextRc;
	m_text.GetRect(&recTextRc);

	int wRecTextRc = recTextRc.Width();
	int hRecTextRc = recTextRc.Height();

	// CStatic icon is used to load standard MessageBox icon
	// ------------------------------------------------------

	m_icon.ModifyStyle(0, WS_CHILD | WS_VISIBLE | SS_ICON | SS_CENTERIMAGE );

	LPWSTR lpIcon = 0;
	lpIcon = IDI_EXCLAMATION;
	lpIcon = IDI_ASTERISK;
	lpIcon = IDI_HAND;
	lpIcon = IDI_QUESTION;

	m_nStyle = MB_ICONHAND;
	m_nStyle = MB_ICONEXCLAMATION;

	if (m_nStyle & MB_ICONMASK)
	{
		lpIcon = IDI_EXCLAMATION;

		switch (m_nStyle & MB_ICONMASK)
		{
		case MB_ICONEXCLAMATION: lpIcon = IDI_EXCLAMATION; break;
		case MB_ICONHAND:        lpIcon = IDI_HAND;        break;
		case MB_ICONQUESTION:    lpIcon = IDI_QUESTION;    break;
		case MB_ICONASTERISK:    lpIcon = IDI_ASTERISK;    break;
		}
	}

	BOOL winSystemIcon = TRUE;
	int lims = LIM_LARGE;
	CString errorText;
	HICON m_hIcon = LoadMsgBoxIcon(winSystemIcon, lpIcon, lims, errorText);
	if (m_hIcon == 0)
	{
		TRACE(L"%s\n", errorText);
		// ignore ??;
	}

	int cxIcon = GetSystemMetrics(SM_CXICON);
	int cyIcon = GetSystemMetrics(SM_CYICON);

	int SpacingSize = 16;

	CRect iconrect;

	int iconRecLeft = 0;
	int iconRecTop = 0;
	int iconRecRight = 0;
	int iconRecButtom = 0;

	iconRecLeft = SpacingSize;
	iconRecTop = recTextRc.top + SpacingSize;
	iconRecRight = iconRecLeft + cxIcon + SpacingSize;
	iconRecButtom = iconRecTop + cyIcon + SpacingSize;

	SetRect(&iconrect, iconRecLeft, iconRecTop, iconRecRight, iconRecButtom);

	HICON retIcon = m_icon.SetIcon(m_hIcon);

	m_icon.MoveWindow(iconrect, bRepaint);

	// Determine rectangle for translated text. Translation can return original english text
	// ------------------------------------------------------

	CClientDC dc(&m_text);

	HFONT hfntNew = CMainFrame::m_dfltFont.operator HFONT();

	// Determine text total length/width and height
	// Width will not be used

	HFONT hfntOld = (HFONT)dc.SelectObject(hfntNew);
	dc.SetTextColor(RGB(0, 0, 0));

	CSize textSize;
	textSize = dc.GetTextExtent(m_textStr);

	dc.SelectObject(hfntOld);
	//

	int textLen = m_textStr.GetLength();
	CString longestWordText;
	int longetWordLen = LongestWordLength(m_textStr, &longestWordText);
	int wordLen = longestWordText.GetLength();

	CString longestLineText;
	int longetLineLen = LongestLineLength(m_textStr, &longestLineText);
	int lineLen = longestLineText.GetLength();

	ResHelper::TranslateString(m_textStr);
	m_textStr.Replace(L"\n", L"\r\n");

	// Best if we can determine longest word and line for translated text
	// This is not trivial for some languages

	int screenWidth = GetSystemMetrics(SM_CXSCREEN); // the width of the primary display.
	int screenHeight = GetSystemMetrics(SM_CYSCREEN); // the height of the primary display.

	// Decide on new text rectagle width, critical for other  calculations 

	// This is used during development
	// Need to decide on max width and possibly the longest word
	// User will have option to resize manually if desired

	int maxTextRectagleWidth = screenWidth / 2;
	int configTextRectagleWidth = 600;  // ???

	configTextRectagleWidth = configTextRectagleWidth + 0.25 * ((float)configTextRectagleWidth * CMainFrame::m_cnfFontSize) / CMainFrame::m_dfltFontSize;

	int textRectagleWidth = configTextRectagleWidth;
	if (textRectagleWidth > maxTextRectagleWidth)
		textRectagleWidth = maxTextRectagleWidth;

	// Aproximate, may need to do better later
	longetWordLen = ((float)textSize.cx * longetWordLen) / longestWordText.GetLength();
	longetLineLen = ((float)textSize.cx * longetLineLen) / longestLineText.GetLength();
	if ((longetWordLen < textRectagleWidth) && (longetLineLen < textRectagleWidth))
	{
		textRectagleWidth = max(longetWordLen, longetLineLen);
	}

	m_text.SetWindowText(m_textStr);

	int textRecLeft = iconrect.right;
	int textRecTop = recTextRc.top + SpacingSize;
	int textRecRight = textRecLeft + textRectagleWidth;
	int textRecButtom = textRecTop + screenHeight / 2;

	CRect newTextRec;
	newTextRec.SetRect(textRecLeft, textRecTop, textRecRight, textRecButtom);

	m_text.SetRect(&newTextRec);
	m_text.MoveWindow(newTextRec, bRepaint);

	CRect newRecDlgRc;

	int newRecDlgRcLeft = recDlgRc.left;
	int newRecDlgRcTop = recDlgRc.top;
	int newRecDlgRcRight = recDlgRc.right + (newTextRec.Width() - recTextRc.Width()) + 32;
	int newRecDlgRcButtom = recDlgRc.bottom + newTextRec.Height();

	newRecDlgRc.SetRect(newRecDlgRcLeft, newRecDlgRcTop, newRecDlgRcRight, newRecDlgRcButtom);
	MoveWindow(&newRecDlgRc, bRepaint);

	if ((CmboxviewApp::m_isRTL == TRUE) && (CmboxviewApp::m_isRTLForDialogs))
	{
		newTextRec.left -= 2 * SpacingSize;
		newTextRec.right -= 1 * SpacingSize;
		//newTextRec.DeflateRect(-2*SpacingSize, 0);

		m_text.SetRect(&newTextRec);
		m_text.MoveWindow(newTextRec, bRepaint);

		iconRecLeft = newRecDlgRc.Width() - (cxIcon + 2*SpacingSize);
		iconRecTop = newTextRec.top;
		iconRecRight = newRecDlgRc.Width() - 2*SpacingSize;
		iconRecButtom = iconRecTop + cyIcon + SpacingSize;

		SetRect(&iconrect, iconRecLeft, iconRecTop, iconRecRight, iconRecButtom);
		HICON retIcon = m_icon.SetIcon(m_hIcon);
		m_icon.MoveWindow(iconrect, bRepaint);
	}

	int lcnt = m_text.GetLineCount();

	// Need to do extra MoveWindow for proper scaling. Figure out later why 

	int newTextHeigth = lcnt*textSize.cy;
	newRecDlgRcButtom = recDlgRc.bottom + (newTextHeigth - recTextRc.Height());

	newRecDlgRc.SetRect(newRecDlgRcLeft, newRecDlgRcTop, newRecDlgRcRight, newRecDlgRcButtom);
	MoveWindow(&newRecDlgRc, bRepaint);

	ResHelper::LoadDialogItemsInfo(this);
	ResHelper::UpdateDialogItemsInfo(this);
	//BOOL retA = ResHelper::ActivateToolTips(this, m_toolTip);

	SetFocus();

	return TRUE;  // return TRUE unless you set the focus to a control
	// EXCEPTION: OCX Property Pages should return FALSE
}

HICON CustomMsgBox::LoadMsgBoxIcon(BOOL systemIcon, PCWSTR pszName, int lims, CString &errorText)
{
	HICON hIcon = 0;
	HINSTANCE hInst = 0;
	if (!systemIcon)
		hInst = ::GetModuleHandle(0);

	HRESULT retCode = LoadIconMetric(hInst, pszName, lims, &hIcon);
	if (retCode == S_OK)
	{
		_ASSERTE(hIcon);
		return hIcon;
	}
	else
	{
		errorText = FileUtils::GetLastErrorAsString();
		DWORD err = GetLastError();
		TRACE(L"(LoadMsgBoxIcon)error=%ld\n%s\n", err, errorText);
	}
	// Lets try LoadIcon
	// 	
	hIcon = ::LoadIcon(hInst, pszName);
	if (hIcon)
	{
		return hIcon;
	}
	else
	{
		errorText = FileUtils::GetLastErrorAsString();
		DWORD err = GetLastError();
		TRACE(L"(LoadMsgBoxIcon)error=%ld\n%s\n", err, errorText);
	}
	// Lets try LoadImage
	// 	
	int cxx = 0;
	int  cyy = 0;
	UINT fuLoad = LR_DEFAULTSIZE | LR_SHARED;
	hIcon = (HICON)::LoadImage(hInst, pszName, IMAGE_ICON, cxx, cyy, fuLoad);
	if (hIcon == 0)
	{
		errorText = FileUtils::GetLastErrorAsString();
		DWORD err = GetLastError();
		TRACE(L"(LoadMsgBoxIcon)error=%ld\n%s\n", err, errorText);
	}
	return hIcon;
}

BEGIN_MESSAGE_MAP(CustomMsgBox, CDialogEx)
	//ON_WM_CREATE()
	ON_WM_SIZE()
END_MESSAGE_MAP()


// CustomMsgBox message handlers

int CustomMsgBox::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;
}

void CustomMsgBox::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);
	//TRACE(L"cx=%d cy=%d\n", cx, cy);

	// OnSize can be called before CStatusBar is created
	if (m_wndStatusBar.GetSafeHwnd())
	{
		CRect recWin;
		GetWindowRect(&recWin);
		int pos_cy = cy - m_StatusBarHeight;
		UINT nFlags = SWP_NOZORDER | SWP_SHOWWINDOW | SWP_NOSIZE;
		nFlags = SWP_NOZORDER;
		BOOL retPos = m_wndStatusBar.SetWindowPos(0, 0, pos_cy, cx, m_StatusBarHeight, nFlags);
		int deb = 1;
	}
}

int CustomMsgBox::LongestWordLength(CString& str, CString *longestWord)
{
	int n = str.GetLength();
	int res = 0, curr_len = 0, i;
	int begPos = -1;
	int longestBegPos = 0;
	int longestEndPos = 0;
	wchar_t ch;

	for (i = 0; i < n; i++)
	{
		ch = str[i];
		if ((curr_len == 0) && ((ch == L'\n') || (ch == L'\r')))
		{
			// skip leading CR and NL
			continue;
		}
		else if (begPos == -1)
			begPos = i;

		// If current character is 
		// not end of current word.
		if ((ch != L' ') && (ch != L'\n') && (ch != L'\r'))
		{
			curr_len++;
		}
		else // end of word is found
		{
			if (curr_len > res)
			{
				res = curr_len;
				longestBegPos = begPos;
				longestEndPos = i;
				if (longestWord) {
					longestWord->Empty();
					longestWord->Append(&((LPCWSTR)str)[longestBegPos], res);
				}
			}
			begPos = -1;
			curr_len = 0;
		}
	}

	// We do max one more time to consider last word as there won't be any space after last word.
	if (curr_len > res)
	{
		res = curr_len;
		longestBegPos = begPos;
		longestEndPos = i;
		if (longestWord) {
			longestWord->Empty();
			longestWord->Append(&((LPCWSTR)str)[longestBegPos], res);
		}
	}
	return (res);
}

int CustomMsgBox::LongestLineLength(CString& str, CString *longestLine)
{
	int n = str.GetLength();
	int res = 0, curr_len = 0, i;
	int begPos = -1;
	int longestBegPos = 0;
	int longestEndPos = 0;
	wchar_t ch;

	for (int i = 0; i < n; i++)
	{
		ch = str[i];
		if ((curr_len == 0) && ((ch == L'\n') || (ch == L'\r')))
		{
			// skip leading CR and NL
			continue;
		}
		else if (begPos == -1)
			begPos = i;

		// If current character is 
		// not end of current line.
		if ((ch != L'\n') && (ch != L'\r'))
		{
			curr_len++;
		}
		else // end of line is found
		{
			if (curr_len > res)
			{
				res = curr_len;
				longestBegPos = begPos;
				longestEndPos = i;
				if (longestLine) {
					longestLine->Empty();
					longestLine->Append(&((LPCWSTR)str)[longestBegPos], res);
				}
			}
			begPos = -1;
			curr_len = 0;
		}
	}

	// We do max one more time to consider last line as there won't be any space after last word.
	if (curr_len > res)
	{
		res = curr_len;
		longestBegPos = begPos;
		longestEndPos = i;
		if (longestLine) {
			longestLine->Empty();
			longestLine->Append(&((LPCWSTR)str)[longestBegPos], res);
		}
	}
	return (res);
}

